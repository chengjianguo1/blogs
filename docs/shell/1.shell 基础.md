# 1.shell 基础
- shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统级程序

- 用户可以用 Shell 来启动、挂起、停止或者编写一些程序
- Shell 还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强。
- Shell 是解释执行的脚本语言，在 Shell 中可以直接调用 Linux 系统命令。

## 1.1 查看支持的 shell

- `cat /etc/shells`

查看 shell 的帮助信息

| 命令      | 作用                                   |
| --------- | -------------------------------------- |
| man bash  | 查看 bash 的命令帮助                   |
| info bash | 查看 bash 的文档                       |
| help      | 命令显示 bash 支持的命令               |
| help cd   | 如果想看某个命令的帮助可以 `help` 命令 |

## 1.2 echo

- 输出命令
- --e 支持反斜线控制的字符转换

| 控制字符 | 作用                                                               |
| -------- | ------------------------------------------------------------------ |
| \n       | 换行符                                                             |
| \r       | 回车键                                                             |
| \t       | 制表符，也就是 Tab 键                                              |
| \v       | 垂直制表符                                                         |
| \onnn    | 按照八进制 ASCII 码表输出字符，其中 0 为数字零，nnn 是三位八进制数 |
| \xhh     | 按照十六进制 ASCII 码表输出字符，其中 hh 是两位十六进制数          |

| 符号 | 颜色 |
| ---- | ---- |
| #30m | 黑色 |
| #31  | 红色 |
| #32  | 绿色 |
| #33  | 黄色 |
| #34  | 蓝色 |
| #35  | 洋红 |
| #36  | 青涩 |
| #37  | 白色 |

```
echo -e "12\r\n34\t56\v78"
echo -e "\0141"
echo -e "\x61"
echo -e "\e[1;31m warning \e[0m"
```

## 1.3 编写执行 shell

```
#!/bin/bash
echo -e "\e[1;34m hello world \e[0m"
```

赋予执行权限，直接运行

```
chmod 755 hello.sh
./hello.sh
```

通过 Bash 调用执行脚本

```
bash hello.sh
```

## 1.4 别名

- 命令别名 == 小名
- 临时生效
- alias
- alias rm="rm -i"
- 写入环境变量配置文件 vi ~/.bashrc
- source ~/.bashrc
- unalias 别名 删除别名

## 1.5 命令的生效顺序

- 绝对路径或者相对路径
- 别名
- bash 内部命令
- 按照\$PATH 环境变量定义的目录查找顺序找到的第一个命令

## 1.6 命令快捷键

| 命令   | 含义                       |
| ------ | -------------------------- |
| ctrl+c | 强制终止当前命令           |
| ctrl+l | 清屏                       |
| ctrl+a | 光标移动到命令行首         |
| ctrl+e | 光标移动到命令行尾         |
| ctrl+u | 从光标所在的位置删除到行首 |
| ctrl+z | 把命令放入后台             |
| fg     | 把任务带回前台             |
| ctrl+r | 在历史命令中搜索           |

## 1.7 历史命令

- history [选项][历史命令保存文件]
- 选项
  - -c 清空历史命令
  - -w 把缓存中的历史命令写入历史命令保存文件 ~/.bash_history
- 默认保存 1000 条 /etc/profile HISSIZE=10000

## 1.8 调用

- 使用上下箭头调用以前的历史命令
- 使用 !n 重复执行第 n 条历史命令
- 使用 !! 重复执行上一条命令
- 使用 !字符 重复执行最后一条以该字符串开头的命令

```
history -c
1  echo 1
2  echo 2
3  echo 3
!2
!!
!echo
```

## 1.9 输出重定向

## 1.9.1 标准输入输出

| 设备   | 设备文件名  | 文件描述符 | 类型         |
| ------ | ----------- | ---------- | ------------ |
| 键盘   | /dev/stdin  | 0          | 标准输入     |
| 显示器 | /dev/stdout | 1          | 标准输出     |
| 显示器 | /dev/strerr | 2          | 标准错误输出 |

| 类型                       | 符号                  | 作用                                                               |
| -------------------------- | --------------------- | ------------------------------------------------------------------ |
| 标准输出重定向             | 命令 > 文件           | 以覆盖的方式，把命令的正确输出输出到指定的文件或设备当中           |
| 标准输出重定向             | 命令 >> 文件          | 以追加的方式，把命令的正确输出输出到指定的文件或设备当中           |
| 错误输出重定向             | 命令>文件             | 以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中           |
| 错误输出重定向             | 命令>>文件            | 以追加的方式，把命令的错误输出输出到指定的文件或设备当中           |
| 正确输出和错误输出同时保存 | 命令>文件 2>&1        | 以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中           |
| 正确输出和错误输出同时保存 | 命令>文件 2>>&1       | 以追加的方式，把正确输出和错误输出都保存到同一个文件当中           |
| 正确输出和错误输出同时保存 | 命令&>文件            | 以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中           |
| 正确输出和错误输出同时保存 | 命令&>>文件           | 以追加的方式，把正确输出和错误输出都保存到同一个文件当中           |
| 正确输出和错误输出同时保存 | 命令>>文件 1 2>文件 2 | 以覆盖的方式，正确的输出追加到文件 1 中，把错误输出追加到文件 2 中 |

## 1.9.2 输入重定向

- wc 命令的功能为统计指定文件中的行数、字数、字节数, 并将统计结果显示输出
- 命令 < 文件把文件做为命令的输入
- 命令 << 标识符 标识符把标识符之间内容作为命令的输入

```
- wc < access.log
[root@localhost ~]# wc <<!
> hello world
> !
 1  2 12
```

## 1.10 管道符号

## 1.10.1 多命令顺序执行

| 多命令执行符 | 格式             | 作用                                                                               | 案例            |
| ------------ | ---------------- | ---------------------------------------------------------------------------------- | --------------- |
| ;            | 命令 1;命令 2    | 多个命令执行，命令之间没有任何逻辑联系                                             | echo 1;echo 2;  |
| &&           | 命令 1 && 命令 2 | 逻辑与 当命令 1 正确执行，则命令 2 才会执行 当命令 1 执行不正确，则命令 2 不会执行 | echo 1&&echo 2; |
| \|\|         | 命令 1\\ 命令 2  | 逻辑或 当命令 1 执行不正确，则命令 2 才会执行 当命令 1 正确执行，则命令 2 不会执行 | echo 1\\echo 2; |

```
- date;ls;date;ls
- ls && echo yes || echo no
```

## 1.10.2 管道符号

- 命令 1 的正确输出会作为命令 2 的操作对象
- 命令 1|命令 2

```
ls /etc/ | more
netstat -an | grep ESTABLISHED | wc -l
```

## 1.10.3 通配符

匹配文件名和目录名

| 通配符 | 作用                                        |
| ------ | ------------------------------------------- |
| ?      | 匹配一个任意字符                            |
| \*     | 匹配 0 个或任意字符，也就是可以匹配任意内容 |
| []     | 匹配中括号中任意一个字符                    |
| [-]    | 匹配中括号中任意一个字符,-代表范围          |
| [^]    | 匹配不是中括号中的一个字符                  |

## 1.10.4 其它符号

| 符号 | 作用                                                                                             |
| ---- | ------------------------------------------------------------------------------------------------ |
| ''   | 单引号。在单引号中所有的特殊符号，如\$和`都没有特殊含义                                          |
| ""   | 双引号，在双引号里特殊符号都没有特殊含义，但是 \$ ` \ 例外，拥有调用变量值，引用命令和转义的含义 |
| \`\` | 反引号，扩起来的是系统命令                                                                       |
| \$() | 和反引号一样                                                                                     |
| #    | 在 shell 脚本中，#开头的行代表注释                                                               |
| \$   | 用于调用变量的值                                                                                 |
| \\   | 转义符号                                                                                         |

```
-  a=`ls`
-  b=$(ls)
```